# Task 08: CLI Integration Testing

**Status**: Planned  
**Estimated Time**: 2 days  
**Complexity**: High  
**Prerequisites**: Tasks 01-04 (Testing foundation and template tests)  
**Dependencies**: Complete test suite foundation  

## Overview

Create end-to-end integration tests for CLI commands, ensuring full functionality works correctly across all command scenarios including install, upgrade, and uninstall operations.

## Objectives

- Test all CLI commands end-to-end
- Validate command-line argument parsing
- Test error scenarios and edge cases
- Verify CLI output and exit codes
- Create integration test harness

## Implementation Steps

### Step 1: Create CLI Test Harness
Create `tests/helpers/cli-helper.js`:
```javascript
const { spawn } = require('child_process');\nconst path = require('path');\n\nclass CLITestHarness {\n  constructor() {\n    this.binPath = path.join(__dirname, '../../bin/context-monkey.js');\n  }\n\n  async run(args = [], options = {}) {\n    return new Promise((resolve, reject) => {\n      const child = spawn('node', [this.binPath, ...args], {\n        stdio: 'pipe',\n        ...options\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      child.stdout.on('data', data => {\n        stdout += data.toString();\n      });\n\n      child.stderr.on('data', data => {\n        stderr += data.toString();\n      });\n\n      child.on('close', code => {\n        resolve({\n          code,\n          stdout: stdout.trim(),\n          stderr: stderr.trim()\n        });\n      });\n\n      child.on('error', reject);\n    });\n  }\n}\n\nmodule.exports = { CLITestHarness };\n```

### Step 2: Test Help and Version Commands\nCreate `tests/integration/cli-basic.test.js`:\n```javascript\nconst { CLITestHarness } = require('../helpers/cli-helper');\n\ndescribe('CLI Basic Commands', () => {\n  let cli;\n\n  beforeEach(() => {\n    cli = new CLITestHarness();\n  });\n\n  test('should display help when --help flag used', async () => {\n    const result = await cli.run(['--help']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('Usage:');\n    expect(result.stdout).toContain('install');\n    expect(result.stdout).toContain('upgrade');\n    expect(result.stdout).toContain('uninstall');\n  });\n\n  test('should display version when --version flag used', async () => {\n    const result = await cli.run(['--version']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toMatch(/\\d+\\.\\d+\\.\\d+/);\n  });\n});\n```

### Step 3: Test Install Command\nCreate `tests/integration/cli-install.test.js`:\n```javascript\nconst mockFs = require('mock-fs');\nconst fs = require('fs-extra');\nconst { CLITestHarness } = require('../helpers/cli-helper');\n\ndescribe('CLI Install Command', () => {\n  let cli;\n\n  beforeEach(() => {\n    cli = new CLITestHarness();\n    \n    mockFs({\n      '.monkey/stack.md': '# Test Stack\\nNode.js CLI Tool',\n      '.monkey/rules.md': '# Test Rules\\nUse Commander.js',\n      'templates/commands/test-command.mustache': 'Stack: {{stack}}\\nRules: {{rules}}',\n      'templates/agents/test-agent.mustache': 'Agent for {{projectName}}'\n    });\n  });\n\n  afterEach(() => {\n    mockFs.restore();\n  });\n\n  test('should install successfully with valid project context', async () => {\n    const result = await cli.run(['install']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('Installation completed');\n  });\n\n  test('should fail gracefully without .monkey directory', async () => {\n    mockFs({}); // Empty file system\n    \n    const result = await cli.run(['install']);\n    \n    expect(result.code).not.toBe(0);\n    expect(result.stderr).toContain('.monkey directory not found');\n  });\n\n  test('should handle missing stack.md file', async () => {\n    mockFs({\n      '.monkey/rules.md': '# Test Rules\\nUse Commander.js'\n    });\n    \n    const result = await cli.run(['install']);\n    \n    expect(result.code).not.toBe(0);\n    expect(result.stderr).toContain('stack.md not found');\n  });\n});\n```

### Step 4: Test Upgrade Command\nCreate `tests/integration/cli-upgrade.test.js`:\n```javascript\ndescribe('CLI Upgrade Command', () => {\n  let cli;\n\n  beforeEach(() => {\n    cli = new CLITestHarness();\n    \n    // Mock existing installation\n    mockFs({\n      '.monkey/stack.md': '# Updated Stack\\nNode.js + TypeScript',\n      '.monkey/rules.md': '# Updated Rules\\nUse Jest',\n      '~/.claude-code/commands/existing-command': 'old content',\n      'templates/commands/existing-command.mustache': 'New: {{stack}}'\n    });\n  });\n\n  test('should upgrade existing installation', async () => {\n    const result = await cli.run(['upgrade']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('Upgrade completed');\n  });\n\n  test('should handle upgrade when nothing installed', async () => {\n    mockFs({\n      '.monkey/stack.md': '# Stack\\nNode.js',\n      '.monkey/rules.md': '# Rules\\nUse Jest'\n    });\n    \n    const result = await cli.run(['upgrade']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('No existing installation found');\n  });\n});\n```

### Step 5: Test Uninstall Command\nCreate `tests/integration/cli-uninstall.test.js`:\n```javascript\ndescribe('CLI Uninstall Command', () => {\n  let cli;\n\n  beforeEach(() => {\n    cli = new CLITestHarness();\n    \n    mockFs({\n      '~/.claude-code/commands/context-monkey-command': 'command content',\n      '~/.claude-code/agents/context-monkey-agent': 'agent content'\n    });\n  });\n\n  test('should uninstall successfully', async () => {\n    const result = await cli.run(['uninstall']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('Uninstall completed');\n  });\n\n  test('should handle uninstall when nothing installed', async () => {\n    mockFs({}); // No installed files\n    \n    const result = await cli.run(['uninstall']);\n    \n    expect(result.code).toBe(0);\n    expect(result.stdout).toContain('Nothing to uninstall');\n  });\n});\n```

### Step 6: Test Error Scenarios\nCreate `tests/integration/cli-errors.test.js`:\n```javascript\ndescribe('CLI Error Handling', () => {\n  let cli;\n\n  beforeEach(() => {\n    cli = new CLITestHarness();\n  });\n\n  test('should handle invalid command', async () => {\n    const result = await cli.run(['invalid-command']);\n    \n    expect(result.code).not.toBe(0);\n    expect(result.stderr).toContain('Unknown command');\n  });\n\n  test('should handle file permission errors gracefully', async () => {\n    // Mock read-only file system\n    mockFs({\n      '.monkey/stack.md': mockFs.file({\n        content: '# Stack\\nNode.js',\n        mode: 0o444 // Read-only\n      })\n    });\n    \n    const result = await cli.run(['install']);\n    \n    // Should handle gracefully, not crash\n    expect(result.stderr).toContain('Permission denied');\n  });\n});\n```

### Step 7: Cross-Platform Testing\nCreate `tests/integration/cli-platform.test.js`:\n```javascript\ndescribe('CLI Cross-Platform Compatibility', () => {\n  test('should handle Windows-style paths', async () => {\n    // Test Windows path handling\n    // Mock Windows environment\n  });\n\n  test('should handle Unix-style paths', async () => {\n    // Test Unix path handling\n  });\n\n  test('should handle path separators correctly', async () => {\n    // Test both forward and back slashes\n  });\n});\n```

## Files to Create

### Test Files\n- `tests/integration/cli-basic.test.js` - Basic CLI functionality\n- `tests/integration/cli-install.test.js` - Install command testing\n- `tests/integration/cli-upgrade.test.js` - Upgrade command testing\n- `tests/integration/cli-uninstall.test.js` - Uninstall command testing\n- `tests/integration/cli-errors.test.js` - Error handling\n- `tests/integration/cli-platform.test.js` - Cross-platform testing\n\n### Helper Files\n- `tests/helpers/cli-helper.js` - CLI testing utilities\n- `tests/helpers/mock-claude-code.js` - Mock Claude Code environment\n\n## Expected Outcomes\n\n- Full CLI functionality tested end-to-end\n- Command-line parsing and argument handling verified\n- Error scenarios properly handled\n- Exit codes and output validated\n- Cross-platform compatibility ensured\n\n## Acceptance Criteria\n\n- [ ] All CLI commands tested end-to-end\n- [ ] Help and version commands work correctly\n- [ ] Install/upgrade/uninstall workflows tested\n- [ ] Error scenarios properly handled\n- [ ] Command output and exit codes validated\n- [ ] Cross-platform path handling tested\n- [ ] File permission errors handled gracefully\n\n## Risk Assessment\n\n| Risk | Probability | Impact | Mitigation |\n|------|-------------|--------|-----------|\n| CLI testing complexity | High | Medium | Use established CLI testing patterns |\n| File system integration testing | High | Medium | Comprehensive mocking strategy |\n| Cross-platform testing challenges | Medium | Medium | Test on multiple environments |\n| Mock file system limitations | Medium | Low | Fallback to temp directories if needed |\n\n## Test Categories\n\n### Integration Tests\n- Full command workflows\n- File system interactions\n- Template processing integration\n- Context loading and processing\n\n### Error Handling Tests\n- Invalid arguments\n- Missing files\n- Permission errors\n- Network issues (if applicable)\n\n### Platform Compatibility Tests\n- Windows path handling\n- Unix path handling\n- File permission differences\n- Environment variable handling\n\n## Definition of Done\n\n- All acceptance criteria met\n- CLI commands tested comprehensively\n- Error handling robust and tested\n- Cross-platform compatibility verified\n- Ready for advanced CI features (Tasks 09-12)\n\n## Notes\n\n- Use child_process.spawn for realistic CLI testing\n- Mock file system extensively for isolation\n- Test both success and failure scenarios\n- Validate CLI output format and content\n- Consider testing with different terminal environments