import os from 'os';
import path from 'path';
import fs from 'fs-extra';
import type { InstallOptions } from '../../types/index.js';
import { loadCommandTemplates } from '../../utils/resources.js';
import { renderCommandForTarget } from '../../templates/index.js';
import {
  CODEX_LEGACY_PROMPT_PREFIXES,
  CODEX_AGENTS_BEGIN_MARKER,
  CODEX_AGENTS_END_MARKER,
  stripCodexAgentsBlock,
} from '../../utils/codex.js';
import { TargetAgent } from '../../types/index.js';

import packageJsonData from '../../../package.json' with { type: 'json' };
const packageJson = packageJsonData;

type CodexInstallOptions = Pick<InstallOptions, 'assumeYes'>;

export async function installCodex(options: CodexInstallOptions): Promise<void> {
  const { assumeYes } = options;
  void assumeYes; // reserved for future use (Codex currently has no prompts to confirm)
  const homeDir = os.homedir();
  const codexDir = path.join(homeDir, '.codex');
  const promptsDir = path.join(codexDir, 'prompts');
  const agentsFile = path.join(codexDir, 'AGENTS.md');

  await fs.ensureDir(codexDir);
  await fs.ensureDir(promptsDir);

  // Clean up legacy directory-based installation and previous generated prompts
  const legacyDir = path.join(promptsDir, 'context-monkey');
  if (await fs.pathExists(legacyDir)) {
    try {
      await fs.remove(legacyDir);
    } catch {
      // ignore legacy removal errors
    }
  }
  await removeExistingContextMonkeyPrompts(promptsDir);

  const resourcesDir = path.join(import.meta.dirname, '../../../resources');
  const commandTemplates = loadCommandTemplates(resourcesDir);
  const renderedCommands = commandTemplates.map(template =>
    renderCommandForTarget(template, TargetAgent.CODEX_CLI)
  );

  console.log('Installing Context Monkey resources for Codex CLI...');

  const generatedSlugs: string[] = [];

  for (const rendered of renderedCommands) {
    const targetPath = path.join(promptsDir, rendered.targetRelativePath);
    const banner = `<!-- Generated by Context Monkey v${packageJson.version}. Do not edit manually. -->\n\n`;
    await fs.writeFile(targetPath, `${banner}${rendered.content}`, 'utf8');
    const slug = rendered.targetRelativePath.replace(/\.md$/i, '');
    generatedSlugs.push(slug);
  }

  await updateAgentsFile(agentsFile, generatedSlugs);

  console.log('  ~/.codex/prompts/               - Context Monkey prompts installed');
  console.log('  ~/.codex/AGENTS.md              - Context Monkey guidance inserted');
  console.log('âœ… Codex CLI resources installed');
}

async function updateAgentsFile(agentsFile: string, slugs: string[]): Promise<void> {
  const sampleCommands = slugs.slice(0, 3).map(slug => `/${slug}`);
  const summaryLines = [
    '## Context Monkey',
    '',
    'Context Monkey prompts are available as slash commands (e.g. /cm-intro).',
    sampleCommands.length > 0
      ? `Sample commands: ${sampleCommands.join(', ')}`
      : 'Sample commands: (none)',
    '',
    `Installed prompts: ${slugs.length}`,
  ];

  const block = `${CODEX_AGENTS_BEGIN_MARKER}\n${summaryLines.join('\n')}\n${CODEX_AGENTS_END_MARKER}\n`;

  let existing = '';
  if (await fs.pathExists(agentsFile)) {
    existing = await fs.readFile(agentsFile, 'utf8');
  }

  const cleaned = stripCodexAgentsBlock(existing);
  const updated = cleaned.trim().length > 0 ? `${cleaned.trim()}\n\n${block}` : `${block}`;
  await fs.writeFile(agentsFile, `${updated.trim()}\n`, 'utf8');
}

async function removeExistingContextMonkeyPrompts(promptsDir: string): Promise<void> {
  if (!(await fs.pathExists(promptsDir))) {
    return;
  }

  const entries = await fs.readdir(promptsDir);
  const deletions = entries.map(async name => {
    const shouldRemove =
      CODEX_LEGACY_PROMPT_PREFIXES.some(prefix => name.startsWith(prefix)) &&
      name.toLowerCase().endsWith('.md');
    const legacyDir = name === 'context-monkey';

    if (!shouldRemove && !legacyDir) {
      return;
    }

    try {
      await fs.remove(path.join(promptsDir, name));
    } catch {
      // ignore errors during cleanup
    }
  });

  await Promise.all(deletions);
}
