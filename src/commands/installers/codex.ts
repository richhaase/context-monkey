import os from 'os';
import path from 'path';
import fs from 'fs-extra';
import type { InstallOptions } from '../../types/index.js';
import { loadCommandTemplates } from '../../utils/resources.js';
import {
  CODEX_PROMPT_PREFIX,
  CODEX_LEGACY_PROMPT_PREFIXES,
  CODEX_AGENTS_BEGIN_MARKER,
  CODEX_AGENTS_END_MARKER,
  stripCodexAgentsBlock,
} from '../../utils/codex.js';

import packageJsonData from '../../../package.json' with { type: 'json' };
const packageJson = packageJsonData;

type CodexInstallOptions = Pick<InstallOptions, 'assumeYes'>;

export async function installCodex(options: CodexInstallOptions): Promise<void> {
  const { assumeYes } = options;
  void assumeYes; // reserved for future use (Codex currently has no prompts to confirm)
  const homeDir = os.homedir();
  const codexDir = path.join(homeDir, '.codex');
  const promptsDir = path.join(codexDir, 'prompts');
  const agentsFile = path.join(codexDir, 'AGENTS.md');

  await fs.ensureDir(codexDir);
  await fs.ensureDir(promptsDir);

  // Clean up legacy directory-based installation and previous generated prompts
  const legacyDir = path.join(promptsDir, 'context-monkey');
  if (await fs.pathExists(legacyDir)) {
    try {
      await fs.remove(legacyDir);
    } catch {
      // ignore legacy removal errors
    }
  }
  await removeExistingContextMonkeyPrompts(promptsDir);

  const resourcesDir = path.join(import.meta.dirname, '../../../resources');
  const commandTemplates = loadCommandTemplates(resourcesDir);

  console.log('Installing Context Monkey resources for Codex CLI...');

  const generatedSlugs: string[] = [];

  for (const template of commandTemplates) {
    const slug = createCodexPromptSlug(template.relativePath);
    const targetPath = path.join(promptsDir, `${slug}.md`);
    const banner = `<!-- Generated by Context Monkey v${packageJson.version}. Do not edit manually. -->\n\n`;
    const body = transformCodexPrompt(template.body);
    await fs.writeFile(targetPath, `${banner}${body}\n`, 'utf8');
    generatedSlugs.push(slug);
  }

  await updateAgentsFile(agentsFile, generatedSlugs);

  console.log('  ~/.codex/prompts/               - Context Monkey prompts installed');
  console.log('  ~/.codex/AGENTS.md              - Context Monkey guidance inserted');
  console.log('âœ… Codex CLI resources installed');
}

async function updateAgentsFile(agentsFile: string, slugs: string[]): Promise<void> {
  const sampleCommands = slugs.slice(0, 3).map(slug => `/${slug}`);
  const summaryLines = [
    '## Context Monkey',
    '',
    'Context Monkey prompts are available as slash commands (e.g. /cm-intro).',
    sampleCommands.length > 0
      ? `Sample commands: ${sampleCommands.join(', ')}`
      : 'Sample commands: (none)',
    '',
    `Installed prompts: ${slugs.length}`,
  ];

  const block = `${CODEX_AGENTS_BEGIN_MARKER}\n${summaryLines.join('\n')}\n${CODEX_AGENTS_END_MARKER}\n`;

  let existing = '';
  if (await fs.pathExists(agentsFile)) {
    existing = await fs.readFile(agentsFile, 'utf8');
  }

  const cleaned = stripCodexAgentsBlock(existing);
  const updated = cleaned.trim().length > 0 ? `${cleaned.trim()}\n\n${block}` : `${block}`;
  await fs.writeFile(agentsFile, `${updated.trim()}\n`, 'utf8');
}

async function removeExistingContextMonkeyPrompts(promptsDir: string): Promise<void> {
  if (!(await fs.pathExists(promptsDir))) {
    return;
  }

  const entries = await fs.readdir(promptsDir);
  const deletions = entries
    .filter(
      name =>
        CODEX_LEGACY_PROMPT_PREFIXES.some(prefix => name.startsWith(prefix)) &&
        name.toLowerCase().endsWith('.md')
    )
    .map(async name => {
      try {
        await fs.remove(path.join(promptsDir, name));
      } catch {
        // ignore errors during cleanup
      }
    });

  await Promise.all(deletions);
}

function createCodexPromptSlug(relativePath: string): string {
  const withoutExt = relativePath.replace(/\.md$/i, '');
  const normalized = withoutExt.replace(/[\\/]+/g, '-');
  const sanitized = normalized.replace(/[^a-zA-Z0-9-]/g, '-').replace(/-+/g, '-');
  let trimmed = sanitized.replace(/^-/, '').replace(/-$/, '');
  if (!trimmed) {
    trimmed = 'prompt';
  }
  return `${CODEX_PROMPT_PREFIX}${trimmed}`.toLowerCase();
}

function transformCodexPrompt(original: string): string {
  let content = original;

  const replacements: Array<[RegExp, string]> = [
    [/Claude Code/gi, 'Codex CLI'],
    [/\bsubagent(s)?\b/gi, 'workflow$1'],
    [/Task tool/gi, 'internal workflow'],
    [/cm-([a-z-]+)/gi, 'context monkey $1 workflow'],
    [/\/cm:/g, '/cm-'],
  ];

  replacements.forEach(([pattern, value]) => {
    content = content.replace(pattern, value);
  });

  // Remove references to project-specific files not available in Codex
  content = content.replace(/`?@\.cm\/[\w\-.]+`?/g, 'project documentation');

  // Simplify "When this command runs" sections
  content = content.replace(
    /When this command runs, Codex CLI will:?[^]*?(?=\n\n#|\n##|$)/gi,
    'Recommended execution steps:\n'
  );

  // Collapse multiple consecutive blank lines
  content = content.replace(/\n{3,}/g, '\n\n');

  return content.trim();
}
